<html>
    <head>
        <meta charset="utf-8">
        <title>Import WebRTC Event log dumps, show some graphs and download a pcap</title>
        <style>

        </style>
        <!-- highcharts is used under the terms of
            http://shop.highsoft.com/faq/non-commercial
        -->
        <script src="https://code.highcharts.com/highcharts.js"></script>
        <script src="https://cdn.rawgit.com/dcodeIO/protobuf.js/6.11.3/dist/protobuf.min.js"></script>
        <script src="pcap.js"></script>
    </head>
    <body>
        <form><input type="file" onchange="doImport(event)"></form>
        <span id="download"></span>
        <div id="graph"></div>
    </body>
    <script>
let file;
function doImport(evt) {
    evt.target.disabled = true;
    const stream = protoRoot.lookupType('webrtc.rtclog.EventStream');

    const files = evt.target.files;
    file = files[0];
    const reader = new FileReader();
    reader.onload = ((file) => {
        // WebRTC-internals follows a certain format when creating the log file.
        // Try to interpret it as the timestamp of the capture, other
        let absolabsoluteStartTimeUsuteStartUs = 0;
        const dateMatch = file.name.match(/.*_(\d\d\d\d)(\d\d)(\d\d)_(\d\d)(\d\d)_(\d+)_.*.log/);
        if (dateMatch) {
            absoluteStartTimeUs = new Date(dateMatch[1], dateMatch[2], dateMatch[3], dateMatch[4], dateMatch[5], dateMatch[6]).getTime() * 1000;
        }
        return (e) => {
            const events = stream.decode(new Uint8Array(e.target.result));
            events.stream.forEach((event) => decode(event, events.stream[0].timestampUs, absoluteStartTimeUs));
            plot();
            savePCAP();
        };
    })(files[0]);
    reader.readAsArrayBuffer(files[0]);
}
let protoRoot;
const p = protobuf.load('rtc_event_log.proto', (err, root) => {
    if (err) {
        console.error(err);
        return;
    }
    document.querySelector('input').disabled = false;
    protoRoot = root;
});

let basetime;
const bweProbeClusters = [];
const bweProbeResults = [];
const lossBasedUpdates = [];
const delayBasedUpdates = [];
const pcap = new PCAPWriter();
function decode(event, startTimeUs, absoluteStartTimeUs) {
    const relativeTimeMs = (event.timestampUs - startTimeUs) / 1000;
    const absoluteTimeMs = absoluteStartTimeUs / 1000 + relativeTimeMs;
    switch(event.type) {
        case 3: //'RTP_EVENT':
            pcap.write(event.rtpPacket.header, event.rtpPacket.incoming, event.rtpPacket.packetLength, absoluteStartTimeUs + event.timestampUs - startTimeUs);
            break;
        case 4: //'RTCP_EVENT':
            pcap.write(event.rtcpPacket.packetData, event.rtcpPacket.incoming, event.rtcpPacket.packetData.byteLength, absoluteStartTimeUs + event.timestampUs - startTimeUs);
            break;
        case 5: // audio playout event, ignore
            break;
        case 6: // loss based bwe update
            lossBasedUpdates.push([absoluteTimeMs, event.lossBasedBweUpdate.bitrateBps]);
            break;
        case 7: // delay based bwe update
            delayBasedUpdates.push([absoluteTimeMs, event.delayBasedBweUpdate.bitrateBps]);
            break;
        case 17: // BweProbeCluster
            bweProbeClusters.push({
                x: absoluteTimeMs,
                y: event.probeCluster.bitrateBps,
                name: event.probeCluster.id,
            });
            break;
        case 18: // BweProbeResult
            bweProbeResults.push({
                x: absoluteTimeMs,
                y: event.probeResult.bitrateBps,
                name: event.probeResult.id,
            });
            break;
        case 19: // AlrState
            break;
        default:
            //console.log(event.type, event);
            break;
    }
}

function plot() {
    const graph = new Highcharts.Chart({
        title: {
            text: 'BWE probe results'
        },
        xAxis: {
            type: 'datetime',
        },
        yAxis: {
            min: 0,
        },
        plotOptions: {
            scatter: {
                dataLabels: {
                    format: '{point.name}',
                    enabled: true
                },
            }
        },
        chart: {
            zoomType: 'x',
            renderTo : 'graph',
        },
        series: [
            {
                name: 'BWE probe clusters',
                type: 'scatter',
                data: bweProbeClusters,
            },
            {
                name: 'BWE probe results',
                type: 'scatter',
                data: bweProbeResults,
            },
            {
                name: "Loss based updates",
                data: lossBasedUpdates,
            },
            {
                name: "Delay based updates",
                data: delayBasedUpdates,
            }
        ],
    });
}
function savePCAP() {
    const blob = pcap.save();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = file.name + '.pcap';
    a.innerText = 'Download PCAP';
    document.getElementById('download').appendChild(a);
}
    </script>
</html>
